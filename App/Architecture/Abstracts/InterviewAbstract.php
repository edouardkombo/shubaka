<?php

namespace App\Architecture\Abstracts;

use App\Architecture\Interfaces\InterviewInterface;
use App\Sequences\SequenceLoader;
use Seld\CliPrompt\CliPrompt;

/**
 * We extend the contract for all the concrete classes
 */
abstract class InterviewAbstract implements InterviewInterface
{
  public $enabled = false;

  public $sequences = [];

  public $credits = [
    "file" => "%s Design Pattern - %s",
    "generated" => "This file is auto-generated by Shubaka from @edouardkombo.",
    "author" => "@author Edouard Kombo <edouard.kombo@gmail.com>"
  ];

  public $classesBag = [
    'namespace' => [],
    'controller' => [],
    'subject' => [],
    'observer' => [],
    'concrete' => [],
    'interface' => [],
    'abstract' => [],
    'trait' => []
  ];

  /**
   * folder =>
   *    file =>
   *        content
   */
  public $generatorBag = [];

  public $classesBagPointer = "";

  public function __construct($className)
  {
    $this->credits['file'] = sprintf($this->credits['file'], $className, '%s');
    $this->sequences = new \ArrayIterator((new SequenceLoader($className))->list());
  }

  //Same for all generators
  public function prompt(?array $arr = [], ?string $className = '')
  {
    $arg = (empty($arr)) ? $this->sequences : $arr;
    $arg = new \ArrayIterator($arg);

    foreach ($arg as $key => $question) {
      
      if (!is_array($question)) {
        echo $this->_replaceAliases($question, $className);
        $answer = CliPrompt::prompt();

        try {
          if (in_array($key, ['concrete','controller'])) {
            if (strpos($answer, "\\") === false) {
              throw new \Exception("Invalid Namespace $answer, expected a valid namespace \n");
            }

            $answer = $this->_retrieveNamespace($answer);
          }
        } catch (\Exception $e) {
          echo $e->getMessage();
          return false;
        }
      }

      if ('decide_reverse' === $key) {
        $answer = (empty($answer)) ? 'n' : $answer;
        if ('n' === strtolower($answer)) {
          continue;
        }
        $arg->rewind();       
      }

      if (strpos($key, '_') !== false) {
        $parts = explode('_', $key);
        
        if ("loop" === $parts[0]) {
          $this->classesBagPointer = $parts[1];

          if (empty($this->classesBag[$this->classesBagPointer])) {
            $this->prompt($this->sequences[$key]);
          } else {
            foreach ($this->classesBag[$this->classesBagPointer] as $cName => $cMethods) {
              $this->prompt($this->sequences[$key], $cName);
            }
          }
        }

      } else {
        if ("method" === $key) {
          $this->classesBag[$this->classesBagPointer][$className]['methods'] = explode(',', ucfirst(trim($answer)));
        } else if (in_array($key, array_keys($this->classesBag)) && !in_array($answer, array_keys($this->classesBag[$key]))) {
          $answer = ucfirst(trim($answer));
          $this->classesBag[$key][$answer] = ["methods" => []];
        }
      }  
    }

    return true;
  }

  abstract public function design();

  //Same for all generators
  public function report()
  {
    foreach ($this->generatorBag as $path => $fileEntries) {
      //Create folder
      mkdir(str_replace('\\', '/', $path), 0777, true);
      echo "---> Creating folder related to $path inside ".__DIR__ . str_replace('\\', '/', $path) . "\n";

      foreach ($fileEntries as $key => $file) {
        foreach ($file as $fileName => $content) {
          //Create files
          file_put_contents(str_replace('\\', '/', $path ."/". $fileName) . ".php", $content);
          echo "---> Writing content related to $fileName inside ".__DIR__ . str_replace('\\', '/', $path ."/". $fileName) .  "\n";
        }
      }
    }
  }

  private function _getLastClassName(string $type, ?string $className = ''): string
  {
    $keys = array_keys($this->classesBag[$type]);
    $totalClasses = count($keys);
    $result = $className;
    
    if (!in_array($className, $keys)) {
      $result = ($totalClasses === 0) ? "__".$type."__" : end($keys);
    }

    return $result;
  }

  private function _replaceAliases(string $dialog, ?string $className = ''): string
  {
    $result = $dialog;

    if (!is_array($dialog) && strpos($dialog, '__') !== false) {
      $result = str_replace(
        ['__concrete__', '__interface__', '__abstract__', '__trait__'],
        [
          $this->_getLastClassName('concrete', $className), 
          $this->_getLastClassName('interface', $className), 
          $this->_getLastClassName('abstract', $className), 
          $this->_getLastClassName('trait', $className)
        ], 
        $dialog
      );
    }

    return $result;
  }

  private function _retrieveNamespace(string $answer)
  {
    $slots = explode('\\', $answer);
    $this->classesBag['namespace'] = implode('\\', array_slice($slots, 0, -1));
    return end($slots);
  }
}