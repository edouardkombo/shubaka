{
  "creational":{
    "abstract_factory": "The abstract factory pattern provides a way to encapsulate a group of individual factories that have a common theme without specifying their concrete classes.\n In normal usage, the client software creates a concrete implementation of the abstract factory and then uses the generic interface of the factory to create the concrete objects that are part of the theme.\n The client does nott know (or care) which concrete objects it gets from each of these internal factories, since it uses only the generic interfaces of their products.\n This pattern separates the details of implementation of a set of objects from their general usage and relies on object composition, as object creation is implemented in methods exposed in the factory interface.\n An example of this would be an abstract factory class DocumentCreator that provides interfaces to create a number of products (e.\ng.\n createLetter() and createResume()).\n The system would have any number of derived concrete versions of the DocumentCreator class like FancyDocumentCreator or ModernDocumentCreator, each with a different implementation of createLetter() and createResume() that would create a corresponding object like FancyLetter or ModernResume.\n Each of these products is derived from a simple abstract class like Letter or Resume of which the client is aware.\n The client code would get an appropriate instance of the DocumentCreator and call its factory methods.\n Each of the resulting objects would be created from the same DocumentCreator implementation and would share a common theme (they would all be fancy or modern objects).\n The client would only need to know how to handle the abstract Letter or Resume class, not the specific version that it got from the concrete factory.\n A factory is the location of a concrete class in the code at which objects are constructed.\n The intent in employing the pattern is to insulate the creation of objects from their usage and to create families of related objects without having to depend on their concrete classes.\n This allows for new derived types to be introduced with no change to the code that uses the base class.\n Use of this pattern makes it possible to interchange concrete implementations without changing the code that uses them, even at runtime.\n However, employment of this pattern, as with similar design patterns, may result in unnecessary complexity and extra work in the initial writing of code.\n Additionally, higher levels of separation and abstraction can result in systems that are more difficult to debug and maintain.\n The essence of the Abstract Factory Pattern is to 'Provide an interface for creating families of related or dependent objects without specifying their concrete classes.\n'",
    "builder": "The Builder is a design pattern designed to provide a flexible solution to various object creation problems in object-oriented programming.\n The intent of the Builder design pattern is to separate the construction of a complex object from its representation.\n It is one of the Gang of Four design patterns.\n The Builder design pattern is one of the GoF design patterns that describe how to solve recurring design problems in object-oriented software.\n The Builder design pattern solves problems like: How can a class (the same construction process) create different representations of a complex object?\n\t How can a class that includes creating a complex object be simplified?\n\t Creating and assembling the parts of a complex object directly within a class is inflexible.\n It commits the class to creating a particular representation of the complex object and makes it impossible to change the representation later independently from (without having to change) the class.\n The Builder design pattern describes how to solve such problems: Encapsulate creating and assembling the parts of a complex object in a separate Builder object.\n A class delegates object creation to a Builder object instead of creating the objects directly.\n A class (the same construction process) can delegate to different Builder objects to create different representations of a complex object.\n The intent of the Builder design pattern is to separate the construction of a complex object from its representation.\n By doing so the same construction process can create different representations.\n Advantages of the Builder pattern include: Allows you to vary a product’s internal representation.\n Encapsulates code for construction and representation.\n Provides control over steps of construction process.\n",
    "factory_method": "The Factory Method design pattern is one of the 'Gang of Four' design patterns that describe how to solve recurring design problems to design flexible and reusable object-oriented software, that is, objects that are easier to implement, change, test, and reuse.\n The Factory Method design pattern is used instead of the regular class constructor for keeping within the SOLID principle of programming, decoupling the construction of objects from the objects themselves.\n This has the following advantages and is useful for the following cases, among others: Allows construction of classes with a component of a type that has not been predetermined, but only defined in an 'interface', or which is defined as a dynamic type.\n Thus, for example, a class Vehicle that has a member Motor of interface IMotor, but no concrete type of Motor defined in advance, can be constructed by telling the Vehicle constructor to use an ElectricMotor or a GasolineMotor.\n The Vehicle constructor code then calls a Motor factory method, to create the desired Motor that complies with the IMotor interface.\n Allows construction of subclasses to a parent whose component type has not been predetermined, but only defined in an interface, or which is defined as a dynamic type.\n For example, a class Vehicle with a member Motor defined with a dynamic type, can have subclasses of type ElectricPlane and OldCar each constructed with a different type of Motor.\n This can be accomplished by constructing the subclasses with a Vehicle factory method, while supplying the motor type.\n In cases like this the constructor may be hidden.\n Allows for more readable code in cases where multiple constructors exist, each for a different reason.\n For example if there are two constructors Vehicle(make:string, motor:number) and Vehicle(make:string, owner:string, license:number, purchased:date) a more readable construction of the classes would be to use Vehicle.\nCreateOwnership(make:string, owner:string, license:number, purchased: date) vs Vehicle.\nCreate(make:string, motor:number) Allows a class to defer instantiation to subclasses, and to prevent direct instantiation of an object of the parent class type.\n For example, a Vehicle can be prevented from being instantiated directly since it has no constructor, and only subclasses like ElectricPlane or OldCar can be created by calling the Vehicle (static) factory method in the subclass constructor or initializer.\n Creating an object directly within the class that requires or uses the object is inflexible because it commits the class to a particular object and makes it impossible to change the instantiation independently of the class.\n A change to the instantiator would require a change to the class code which we would rather not touch.\n This is referred to as code coupling and the Factory method pattern assists in decoupling the code.\n The Factory Method design pattern is used by first defining a separate operation, a factory method, for creating an object, and then using this factory method by calling it to create the object.\n This enables writing of subclasses that decide how a parent object is created and what type of objects the parent contains.\n Define an interface for creating an object, but let subclasses decide which class to instantiate.\n The Factory method lets a class defer instantiation it uses to subclasses.\n (Gang Of Four) Creating an object often requires complex processes not appropriate to include within a composing object.\n The object's creation may lead to a significant duplication of code, may require information not accessible to the composing object, may not provide a sufficient level of abstraction, or may otherwise not be part of the composing object's concerns.\n The factory method design pattern handles these problems by defining a separate method for creating the objects, which subclasses can then override to specify the derived type of product that will be created.\n The factory method pattern relies on inheritance, as object creation is delegated to subclasses that implement the factory method to create objects.\n",
    "multiton": "While it may appear that the multiton is no more than a simple hash table with synchronized access there are two important distinctions.\n First, the multiton does not allow clients to add mappings.\n Secondly, the multiton never returns a null or empty reference; instead, it creates and stores a multiton instance on the first request with the associated key.\n Subsequent requests with the same key return the original instance.\n A hash table is merely an implementation detail and not the only possible approach.\n The pattern simplifies retrieval of shared objects in an application.\n Since the object pool is created only once, being a member associated with the class (instead of the instance), the multiton retains its flat behavior rather than evolving into a tree structure.\n The multiton is unique in that it provides centralized access to a single directory (i.\ne.\n all keys are in the same namespace, per se) of multitons, where each multiton instance in the pool may exist having its own state.\n In this manner, the pattern advocates indexed storage of essential objects for the system (such as would be provided by an LDAP system, for example).\n However, a multiton is limited to wide use by a single system rather than a myriad of distributed systems.\n This pattern, like the Singleton pattern, makes unit testing far more difficult, as it introduces global state into an application.\n With garbage collected languages it may become a source of memory leaks as it introduces global strong references to the objects.\n In software engineering, the multiton pattern is a design pattern which generalizes the singleton pattern.\n Whereas the singleton allows only one instance of a class to be created, the multiton pattern allows for the controlled creation of multiple instances, which it manages through the use of a map.\n Rather than having a single instance per application (e.\ng.\n the java.\nlang.\nRuntime object in the Java programming language) the multiton pattern instead ensures a single instance per key.\n Most people and textbooks consider this a singleton pattern.\n For example, multiton does not explicitly appear in the highly regarded object-oriented programming textbook Design Patterns (it appears as a more flexible approach named registry of singletons).\n",
    "pool": "The object pool pattern is a software creational design pattern that uses a set of initialized objects kept ready to use – a 'pool' – rather than allocating and destroying them on demand.\n A client of the pool will request an object from the pool and perform operations on the returned object.\n When the client has finished, it returns the object to the pool rather than destroying it; this can be done manually or automatically.\n Object pools are primarily used for performance: in some circumstances, object pools significantly improve performance.\n Object pools complicate object lifetime, as objects obtained from and returned to a pool are not actually created or destroyed at this time, and thus require care in implementation.\n When it is necessary to work with a large number of objects that are particularly expensive to instantiate and each object is only needed for a short period of time, the performance of an entire application may be adversely affected.\n An object pool design pattern may be deemed desirable in cases such as these.\n The object pool design pattern creates a set of objects that may be reused.\n When a new object is needed, it is requested from the pool.\n If a previously prepared object is available it is returned immediately, avoiding the instantiation cost.\n If no objects are present in the pool, a new item is created and returned.\n When the object has been used and is no longer needed, it is returned to the pool, allowing it to be used again in the future without repeating the computationally expensive instantiation process.\n It is important to note that once an object has been used and returned, existing references will become invalid.\n In some object pools the resources are limited so a maximum number of objects is specified.\n If this number is reached and a new item is requested, an exception may be thrown, or the thread will be blocked until an object is released back into the pool.\n The object pool design pattern is used in several places in the standard classes of the .\nNET Framework.\n One example is the .\nNET Framework Data Provider for SQL Server.\n As SQL Server database connections can be slow to create, a pool of connections is maintained.\n When you close a connection it does not actually relinquish the link to SQL Server.\n Instead, the connection is held in a pool from which it can be retrieved when requesting a new connection.\n This substantially increases the speed of making connections.\n Object pooling can offer a significant performance boost in situations where the cost of initializing a class instance is high and the rate of instantiation and destruction of a class is high – in this case objects can frequently be reused, and each reuse saves a significant amount of time.\n Object pooling requires resources – memory and possibly other resources, such as network sockets, and thus it is preferable that the number of instances in use at any one time is low, but this is not required.\n The pooled object is obtained in predictable time when creation of the new objects (especially over network) may take variable time.\n These benefits are mostly true for objects that are expensive with respect to time, such as database connections, socket connections, threads and large graphic objects like fonts or bitmaps.\n In other situations, simple object pooling (that hold no external resources, but only occupy memory) may not be efficient and could decrease performance.\n In case of simple memory pooling, the slab allocation memory management technique is more suited, as the only goal is to minimize the cost of memory allocation and deallocation by reducing fragmentation.\n Object pools can be implemented in an automated fashion in languages like C++ via smart pointers.\n In the constructor of the smart pointer, an object can be requested from the pool, and in the destructor of the smart pointer, the object can be released back to the pool.\n In garbage-collected languages, where there are no destructors (which are guaranteed to be called as part of a stack unwind), object pools must be implemented manually, by explicitly requesting an object from the factory and returning the object by calling a dispose method (as in the dispose pattern).\n Using a finalizer to do this is not a good idea, as there are usually no guarantees on when (or if) the finalizer will be run.\n Instead, 'try .\n.\n.\n finally' should be used to ensure that getting and releasing the object is exception-neutral.\n Manual object pools are simple to implement, but harder to use, as they require manual memory management of pool objects.\n",
    "prototype": "The prototype pattern is a creational design pattern in software development. It is used when the type of objects to create is determined by a prototypical instance, which is cloned to produce new objects. This pattern is used to:\n\t avoid subclasses of an object creator in the client application, like the factory method pattern does.\n\t avoid the inherent cost of creating a new object in the standard way (e.g., using the 'new' keyword) when it is prohibitively expensive for a given application.\n\n To implement the pattern, declare an abstract base class that specifies a pure virtual clone() method. Any class that needs a 'polymorphic constructor' capability derives itself from the abstract base class, and implements the clone() operation.\n The client, instead of writing code that invokes the 'new' operator on a hard-coded class name, calls the clone() method on the prototype, calls a factory method with a parameter designating the particular concrete derived class desired, or invokes the clone() method through some mechanism provided by another design pattern.\n The mitotic division of a cell — resulting in two identical cells — is an example of a prototype that plays an active role in copying itself and thus, demonstrates the Prototype pattern. When a cell splits, two cells of identical genotype result. In other words, the cell clones itself.\n\n The Prototype design pattern is one of the twenty-three well-known GoF design patterns that describe how to solve recurring design problems to design flexible and reusable object-oriented software, that is, objects that are easier to implement, change, test, and reuse. \n\n The Prototype design pattern solves problems like:\n\t How can objects be created so that which objects to create can be specified at run-time?\n\t How can dynamically loaded classes be instantiated?\n\t Creating objects directly within the class that requires (uses) the objects is inflexible because it commits the class to particular objects at compile-time and makes it impossible to specify which objects to create at run-time.\n\n The Prototype design pattern describes how to solve such problems:\n\t Define a Prototype object that returns a copy of itself.\n\t Create new objects by copying a Prototype object.\n\n This enables configuration of a class with different Prototype objects, which are copied to create new objects, and even more, Prototype objects can be added and removed at run-time.\n\n Sometimes creational patterns overlap — there are cases when either prototype or abstract factory would be appropriate. At other times they complement each other: abstract factory might store a set of prototypes from which to clone and return product objects (GoF, p126). Abstract factory, builder, and prototype can use singleton in their implementations. (GoF, p81, 134). Abstract factory classes are often implemented with factory methods (creation through inheritance), but they can be implemented using prototype (creation through delegation). (GoF, p95)\n\n Often, designs start out using Factory Method (less complicated, more customizable, subclasses proliferate) and evolve toward abstract factory, prototype, or builder (more flexible, more complex) as the designer discovers where more flexibility is needed. (GoF, p136)\n Prototype does not require subclassing, but it does require an 'initialize' operation. Factory method requires subclassing, but does not require initialization. (GoF, p116)\n Designs that make heavy use of the composite and decorator patterns often can benefit from Prototype as well. (GoF, p126)\n The rule of thumb could be that you would need to clone() an Object when you want to create another Object at runtime that is a true copy of the Object you are cloning. True copy means all the attributes of the newly created Object should be the same as the Object you are cloning. If you could have instantiated the class by using new instead, you would get an Object with all attributes as their initial values. For example, if you are designing a system for performing bank account transactions, then you would want to make a copy of the Object that holds your account information, perform transactions on it, and then replace the original Object with the modified one. In such cases, you would want to use clone() instead of new.",
    "simple_factory": "The Simple Factory Pattern, is probably one of the most widely used patterns and at the same time it is also one of the most under used software patterns. I frequently come across scenarios in code bases, when developers have encountered a problem and instead of eleganly handling it, they often pollute function methods with additional lines of cruft logic. Which can often be the source of additional logic bugs or lead to scalability and adaptability issues later on.\n\n Simple Factory Pattern is a Factory class in its simplest form, compared to Factory Method Pattern or Abstract Factory Pattern, is a factory object for creating other objects. In simplelest terms Factory helps to keep all object creation in one place and avoid of spreading new key value across codebase.\n\n The classes a Simple Factory Pattern returns will have the same parent class and methods but will perform the task differently dependent of the type of data supplied.\n\n The Simple Factory Pattern can be considered as an introductory pattern to somewhat more subtle\n\t Factory Method Design Pattern\n\t Abstract Factory Pattern\n\n"
  },
  "structural":{
    "adapter_wrapper": "",
    "bridge": "The bridge pattern is a design pattern used in software engineering that is meant to 'decouple an abstraction from its implementation so that the two can vary independently', introduced by the Gang of Four.[1] The bridge uses encapsulation, aggregation, and can use inheritance to separate responsibilities into different classes.\n\tWhen a class varies often, the features of object-oriented programming become very useful because changes to a program's code can be made easily with minimal prior knowledge about the program. The bridge pattern is useful when both the class and what it does vary often. The class itself can be thought of as the abstraction and what the class can do as the implementation. The bridge pattern can also be thought of as two layers of abstraction.\n\tWhen there is only one fixed implementation, this pattern is known as the Pimpl idiom in the C++ world.\n\n The bridge pattern is often confused with the adapter pattern, and is often implemented using the object adapter pattern.\n Variant: The implementation can be decoupled even more by deferring the presence of the implementation to the point where the abstraction is utilized.\n\n The Bridge design pattern is one of the twenty-three well-known GoF design patterns that describe how to solve recurring design problems to design flexible and reusable object-oriented software, that is, objects that are easier to implement, change, test, and reuse.\n\nWhat problems can the Bridge design pattern solve?\n\tAn abstraction and its implementation should be defined and extended independently from each other.\n\tA compile-time binding between an abstraction and its implementation should be avoided so that an implementation can be selected at run-time.\n\tWhen using subclassing, different subclasses implement an abstract class in different ways. But an implementation is bound to the abstraction at compile-time and can't be changed at run-time.\n\nWhat solution does the Bridge design pattern describe?\n\tSeparate an abstraction (Abstraction) from its implementation (Implementor) by putting them in separate class hierarchies.\n\tImplement the Abstraction in terms of (by delegating to) an Implementor object.\n\tThis enables to configure an Abstraction with an Implementor object at run-time.\n\n",
    "composite": "In software engineering, the composite pattern is a partitioning design pattern. The composite pattern describes a group of objects that is treated the same way as a single instance of the same type of object. The intent of a composite is to 'compose' objects into tree structures to represent part-whole hierarchies. Implementing the composite pattern lets clients treat individual objects and compositions uniformly.\n\nThe Composite design pattern is one of the twenty-three well-known GoF design patterns that describe how to solve recurring design problems to design flexible and reusable object-oriented software, that is, objects that are easier to implement, change, test, and reuse.\n\nWhat problems can the Composite design pattern solve?\n\tA part-whole hierarchy should be represented so that clients can treat part and whole objects uniformly.\n\tA part-whole hierarchy should be represented as tree structure.\n\t When defining Part objects and Whole objects that act as containers for Part objects, clients must treat them separately, which complicates client code.\n\nWhat solution does the Composite design pattern describe?\n\tDefine a unified Component interface for both part (Leaf) objects and whole (Composite) objects.\n\nIndividual Leaf objects implement the Component interface directly, and Composite objects forward requests to their child components.\n\nThis enables clients to work through the Component interface to treat Leaf and Composite objects uniformly: Leaf objects perform a request directly, and Composite objects forward the request to their child components recursively downwards the tree structure. This makes client classes easier to implement, change, test, and reuse.\n\nWhen dealing with Tree-structured data, programmers often have to discriminate between a leaf-node and a branch. This makes code more complex, and therefore, more error prone. The solution is an interface that allows treating complex and primitive objects uniformly. In object-oriented programming, a composite is an object designed as a composition of one-or-more similar objects, all exhibiting similar functionality. This is known as a 'has-a' relationship between objects. The key concept is that you can manipulate a single instance of the object just as you would manipulate a group of them. The operations you can perform on all the composite objects often have a least common denominator relationship. For example, if defining a system to portray grouped shapes on a screen, it would be useful to define resizing a group of shapes to have the same effect (in some sense) as resizing a single shape.\n\nComposite should be used when clients ignore the difference between compositions of objects and individual objects. If programmers find that they are using multiple objects in the same way, and often have nearly identical code to handle each of them, then composite is a good choice; it is less complex in this situation to treat primitives and composites as homogeneous.",
    "data_mapper": "In software engineering, the data mapper pattern is an architectural pattern. It was named by Martin Fowler in his 2003 book Patterns of Enterprise Application Architecture. The interface of an object conforming to this pattern would include functions such as Create, Read, Update, and Delete, that operate on objects that represent domain entity types in a data store.\n\nA Data Mapper is a Data Access Layer that performs bidirectional transfer of data between a persistent data store (often a relational database) and an in-memory data representation (the domain layer). The goal of the pattern is to keep the in-memory representation and the persistent data store independent of each other and the data mapper itself. The layer is composed of one or more mappers (or Data Access Objects), performing the data transfer. Mapper implementations vary in scope. Generic mappers will handle many different domain entity types, dedicated mappers will handle one or a few.",
    "decorator": "In object-oriented programming, the decorator pattern is a design pattern that allows behavior to be added to an individual object, dynamically, without affecting the behavior of other objects from the same class. The decorator pattern is often useful for adhering to the Single Responsibility Principle, as it allows functionality to be divided between classes with unique areas of concern. The decorator pattern is structurally nearly identical to the chain of responsibility pattern, the difference being that in a chain of responsibility, exactly one of the classes handles the request, while for the decorator, all classes handle the request.\n\nWhat problems can it solve?\n\tResponsibilities should be added to (and removed from) an object dynamically at run-time.\n\tA flexible alternative to subclassing for extending functionality should be provided.\n\tWhen using subclassing, different subclasses extend a class in different ways. But an extension is bound to the class at compile-time and can't be changed at run-time.\n\nWhat solution does it describe?\n\tDefine Decorator objects that\n\timplement the interface of the extended (decorated) object (Component) transparently by forwarding all requests to it and\n\tperform additional functionality before/after forwarding a request.\n\nThis allows working with different Decorator objects to extend the functionality of an object dynamically at run-time.\n\nA decorator makes it possible to add or alter behavior of an interface at run-time. Alternatively, the adapter can be used when the wrapper must respect a particular interface and must support polymorphic behavior, and the Facade when an easier or simpler interface to an underlying object is desired.\n\n",
    "dependency_injection": "In software engineering, dependency injection is a technique whereby one object supplies the dependencies of another object. A 'dependency' is an object that can be used, for example as a service. Instead of a client specifying which service it will use, something tells the client what service to use. The 'injection' refers to the passing of a dependency (a service) into the object (a client) that would use it. The service is made part of the client's state. Passing the service to the client, rather than allowing a client to build or find the service, is the fundamental requirement of the pattern.\n\nThe intent behind dependency injection is to achieve Separation of Concerns of construction and use of objects. This can increase readability and code reuse.\n\nDependency injection is one form of the broader technique of inversion of control. The client delegates the responsibility of providing its dependencies to external code (the injector). The client is not allowed to call the injector code; it is the injecting code that constructs the services and calls the client to inject them. This means the client code does not need to know about the injecting code, how to construct the services or even which actual services it is using; the client only needs to know about the intrinsic interfaces of the services because these define how the client may use the services. This separates the responsibilities of use and construction.\n\nDependency Injection solves problems such as:\n\nHow can an application or class be independent of how its objects are created?\nHow can the way objects are created be specified in separate configuration files?\nHow can an application support different configurations?\nCreating objects directly within the class that requires the objects is inflexible because it commits the class to particular objects and makes it impossible to change the instantiation later independently from (without having to change) the class. It stops the class from being reusable if other objects are required, and it makes the class hard to test because real objects can't be replaced with mock objects.\n\nA class is no longer responsible for creating the objects it requires, and it doesn't have to delegate instantiation to a factory object as in the Abstract Factory design pattern.Dependency injection separates the creation of a client's dependencies from the client's behavior, which allows program designs to be loosely coupled[8] and to follow the dependency inversion and single responsibility principles.[5][9] It directly contrasts with the service locator pattern, which allows clients to know about the system they use to find dependencies.\n\nAn injection, the basic unit of dependency injection, is not a new or a custom mechanism. It works in the same way that \"parameter passing\" works. Referring to \"parameter passing\" as an injection carries the added implication that it's being done to isolate the client from details.\n\nAn injection is also about what is in control of the passing (never the client) and is independent of how the passing is accomplished, whether by passing a reference or a value.\n\nDependency injection involves four roles:\n\nthe service object(s) to be used\nthe client object that is depending on the service(s) it uses\nthe interfaces that define how the client may use the services\nthe injector, which is responsible for constructing the services and injecting them into the client\nAs an analogy,\n\nservice - an electric, gas, hybrid, or diesel car\nclient - a driver who uses the car the same way regardless of the engine\ninterface - automatic, ensures driver doesn't have to understand engine details like gears\ninjector - the parent who bought the kid the car and decided which kind\nAny object that may be used can be considered a service. Any object that uses other objects can be considered a client. The names have nothing to do with what the objects are for and everything to do with the role the objects play in any one injection.\n\nThe interfaces are the types the client expects its dependencies to be. An issue is what they make accessible. They may truly be interface types implemented by the services but also may be abstract classes or even the concrete services themselves, though this last would violate DIP[11] and sacrifice the dynamic decoupling that enables testing. It's only required that the client does not know which they are and therefore never treats them as concrete, say by constructing or extending them.\n\nThe client should have no concrete knowledge of the specific implementation of its dependencies. It should only know the interface's name and API. As a result, the client won't need to change even if what is behind the interface changes. However, if the interface is refactored from being a class to an interface type (or vice versa) the client will need to be recompiled.[12] This is significant if the client and services are published separately. This unfortunate coupling is one that dependency injection cannot resolve.\n\nThe injector introduces the services into the client. Often, it also constructs the client. An injector may connect together a very complex object graph by treating an object like a client and later as a service for another client. The injector may actually be many objects working together but may not be the client. The injector may be referred to by other names such as: assembler, provider, container, factory, builder, spring, construction code, or main.\n\nDependency injection can be applied as a discipline, one that asks that all objects separate construction and behavior. Relying on a DI framework to perform construction can lead to forbidding the use of the new keyword, or, less strictly, only allowing direct construction of value objects.",
    "facade": "The facade pattern (also spelled façade) is a software-design pattern commonly used in object-oriented programming. Analogous to a facade in architecture, a facade is an object that serves as a front-facing interface masking more complex underlying or structural code. A facade can:\n\nimprove the readability and usability of a software library by masking interaction with more complex components behind a single (and often simplified) API\nprovide a context-specific interface to more generic functionality (complete with context-specific input validation)\nserve as a launching point for a broader refactor of monolithic or tightly-coupled systems in favor of more loosely-coupled code\nDevelopers often use the facade design pattern when a system is very complex or difficult to understand because the system has many interdependent classes or because its source code is unavailable. This pattern hides the complexities of the larger system and provides a simpler interface to the client. It typically involves a single wrapper class that contains a set of members required by the client. These members access the system on behalf of the facade client and hide the implementation details.\n\nWhat problems can the Facade design pattern solve? \n\nTo make a complex subsystem easier to use, a simple interface should be provided for a set of interfaces in the subsystem.\nThe dependencies on a subsystem should be minimized.\nClients that access a complex subsystem directly refer to (depend on) many different objects having different interfaces (tight coupling), which makes the clients hard to implement, change, test, and reuse.\n\nWhat solution does the Facade design pattern describe?\n\nDefine a Facade object that\n\nimplements a simple interface in terms of (by delegating to) the interfaces in the subsystem and\nmay perform additional functionality before/after forwarding a request.\nThis enables to work through a Facade object to minimize the dependencies on a subsystem.\n\nA Facade is used when an easier or simpler interface to an underlying object is desired. Alternatively, an adapter can be used when the wrapper must respect a particular interface and must support polymorphic behavior. A decorator makes it possible to add or alter behavior of an interface at run-time.",
    "fluent_interface": "In software engineering, a fluent interface (as first coined by Eric Evans and Martin Fowler) is a method for designing object oriented APIs based extensively on method chaining with the goal of making the readability of the source code close to that of ordinary written prose, essentially creating a domain-specific language within the interface.\nA fluent interface is normally implemented by using method chaining to implement method cascading (in languages that do not natively support cascading), concretely by having each method return this (self). Stated more abstractly, a fluent interface relays the instruction context of a subsequent call in method chaining, where generally the context is\n\ndefined through the return value of a called method\nself-referential, where the new context is equivalent to the last context\nterminated through the return of a void context.\nNote that a \"fluent interface\" means more than just method cascading via chaining; it entails designing an interface that reads like a DSL, using other techniques like 'nested functions and object scoping'.\n\nThe term 'fluent interface' was coined in late 2005, though this overall style of interface dates to the invention of method cascading in Smalltalk in the 1970s, and numerous examples in the 1980s. A common example is the iostream library in C++, which uses the << or >> operators for the message passing, sending multiple data to the same object and allowing 'manipulators' for other method calls. Other early examples include the Garnet system (from 1988 in Lisp) and the Amulet system (from 1994 in C++) which used this style for object creation and property assignment.",
    "flyweight": "In computer programming, flyweight is a software design pattern. A flyweight is an object that minimizes memory usage by sharing as much data as possible with other similar objects; it is a way to use objects in large numbers when a simple repeated representation would use an unacceptable amount of memory. Often some parts of the object state can be shared, and it is common practice to hold them in external data structures and pass them to the objects temporarily when they are used.\n\nA classic example usage of the flyweight pattern is the data structures for graphical representation of characters in a word processor. It might be desirable to have, for each character in a document, a glyph object containing its font outline, font metrics, and other formatting data, but this would amount to hundreds or thousands of bytes for each character. Instead, for every character there might be a reference to a flyweight glyph object shared by every instance of the same character in the document; only the position of each character (in the document and/or the page) would need to be stored internally.\n\nAnother example is string interning.\n\nIn other contexts the idea of sharing identical data structures is called hash consing.\n\nThe Flyweight design pattern is one of the twenty-three well-known GoF design patterns that describe how to solve recurring design problems to design flexible and reusable object-oriented software, that is, objects that are easier to implement, change, test, and reuse.\n\nWhat problems can the Flyweight design pattern solve?\n\nLarge numbers of objects should be supported efficiently.\nCreating large numbers of objects should be avoided.\nWhen representing large text documents, for example, creating an object for each character in the document would result in a huge number of objects that could not be processed efficiently.\n\nWhat solution does the Flyweight design pattern describe?\n\nDefine Flyweight objects that\n\nstore intrinsic (invariant) state that can be shared and\nprovide an interface through which extrinsic (variant) state can be passed in.\nThis enables clients to (1) reuse (share) Flyweight objects (instead of creating a new object each time) and (2) pass in extrinsic state when they invoke a Flyweight operation. \nThis greatly reduces the number of physically created objects. \nIntrinsic state is invariant (context independent) and therefore can be shared (for example, the code of character 'A' in a given character set). \nExtrinsic state is variant (context dependent) and therefore can not be shared and must be passed in (for example, the position of character 'A' in a text document).\n\nAccording to the textbook Design Patterns: Elements of Reusable Object-Oriented Software, the flyweight pattern was first coined and extensively explored by Paul Calder and Mark Linton in 1990 to efficiently handle glyph information in a WYSIWYG document editor, although similar techniques were already used in other systems, e.g., an application framework by Weinand et al. (1988).",
    "proxy": "In computer programming, the proxy pattern is a software design pattern. A proxy, in its most general form, is a class functioning as an interface to something else. The proxy could interface to anything: a network connection, a large object in memory, a file, or some other resource that is expensive or impossible to duplicate. In short, a proxy is a wrapper or agent object that is being called by the client to access the real serving object behind the scenes. Use of the proxy can simply be forwarding to the real object, or can provide additional logic. In the proxy, extra functionality can be provided, for example caching when operations on the real object are resource intensive, or checking preconditions before operations on the real object are invoked. For the client, usage of a proxy object is similar to using the real object, because both implement the same interface.\n\nWhat problems can the Proxy design pattern solve?\nThe access to an object should be controlled.\nAdditional functionality should be provided when accessing an object.\nWhen accessing sensitive objects, for example, it should be possible to check that clients have the needed access rights.\n\nWhat solution does the Proxy design pattern describe?\nDefine a separate Proxy object that\n\ncan be used as substitute for another object (Subject) and\nimplements additional functionality to control the access to this subject.\nThis enables to work through a Proxy object to perform additional functionality when accessing a subject. For example, to check the access rights of clients accessing a sensitive object. \nTo act as substitute for a subject, a proxy must implement the Subject interface. Clients can't tell whether they work with a subject or its proxy.\n\nRemote proxy\nIn distributed object communication, a local object represents a remote object (one that belongs to a different address space). The local object is a proxy for the remote object, and method invocation on the local object results in remote method invocation on the remote object. An example would be an ATM implementation, where the ATM might hold proxy objects for bank information that exists in the remote server.\n\nVirtual proxy\nFurther information: Lazy loading\nIn place of a complex or heavy object, a skeleton representation may be advantageous in some cases. When an underlying image is huge in size, it may be represented using a virtual proxy object, loading the real object on demand.\n\nProtection proxy\nA protection proxy might be used to control access to a resource based on access rights."     
  },
  "behavioral":{
    "chain_of_responsibilities": "In object-oriented design, the chain-of-responsibility pattern is a design pattern consisting of a source of command objects and a series of processing objects.[1] Each processing object contains logic that defines the types of command objects that it can handle; the rest are passed to the next processing object in the chain. A mechanism also exists for adding new processing objects to the end of this chain. Thus, the chain of responsibility is an object oriented version of the if ... else if ... else if ....... else ... endif idiom, with the benefit that the condition–action blocks can be dynamically rearranged and reconfigured at runtime.\n\nIn a variation of the standard chain-of-responsibility model, some handlers may act as dispatchers, capable of sending commands out in a variety of directions, forming a tree of responsibility. In some cases, this can occur recursively, with processing objects calling higher-up processing objects with commands that attempt to solve some smaller part of the problem; in this case recursion continues until the command is processed, or the entire tree has been explored. An XML interpreter might work in this manner.\n\nThis pattern promotes the idea of loose coupling.\n\nThe chain-of-responsibility pattern is structurally nearly identical to the decorator pattern, the difference being that for the decorator, all classes handle the request, while for the chain of responsibility, exactly one of the classes in the chain handles the request. This is a strict definition of the Responsibility concept in the GoF book. However, many implementations (such as loggers below, or UI event handling, or servlet filters in Java, etc) allow several elements in the chain to take responsibility.\n\nWhat problems can the Chain of Responsibility design pattern solve?\n\nCoupling the sender of a request to its receiver should be avoided.\nIt should be possible that more than one receiver can handle a request.\nImplementing a request directly within the class that sends the request is inflexible because it couples the class to a particular receiver and makes it impossible to support multiple receivers.\n\nWhat solution does the Chain of Responsibility design pattern describe?\n\nDefine a chain of receiver objects having the responsibility, depending on run-time conditions, to either handle a request or forward it to the next receiver on the chain (if any).\nThis enables to send a request to a chain of receivers without having to know which one handles the request. The request gets passed along the chain until a receiver handles the request. The sender of a request is no longer coupled to a particular receiver.",
    "command": "In object-oriented programming, the command pattern is a behavioral design pattern in which an object is used to encapsulate all information needed to perform an action or trigger an event at a later time. This information includes the method name, the object that owns the method and values for the method parameters.\n\nFour terms always associated with the command pattern are command, receiver, invoker and client. A command object knows about receiver and invokes a method of the receiver. Values for parameters of the receiver method are stored in the command. The receiver object to execute these methods is also stored in the command object by aggregation. The receiver then does the work when the execute() method in command is called. An invoker object knows how to execute a command, and optionally does bookkeeping about the command execution. The invoker does not know anything about a concrete command, it knows only about the command interface. Invoker object(s), command objects and receiver objects are held by a client object, the client decides which receiver objects it assigns to the command objects, and which commands it assigns to the invoker. The client decides which commands to execute at which points. To execute a command, it passes the command object to the invoker object.\n\nUsing command objects makes it easier to construct general components that need to delegate, sequence or execute method calls at a time of their choosing without the need to know the class of the method or the method parameters. Using an invoker object allows bookkeeping about command executions to be conveniently performed, as well as implementing different modes for commands, which are managed by the invoker object, without the need for the client to be aware of the existence of bookkeeping or modes.\n\nThe central ideas of this design pattern closely mirror the semantics of first-class functions and higher-order functions in functional programming languages. Specifically, the invoker object is a higher-order function of which the command object is a first-class argument.\n\nUsing the Command design pattern can solve these problems:\n\nCoupling the invoker of a request to a particular request should be avoided. That is, hard-wired requests should be avoided.\nIt should be possible to configure an object (that invokes a request) with a request.\nImplementing (hard-wiring) a request directly into a class is inflexible because it couples the class to a particular request at compile-time, which makes it impossible to specify a request at run-time.\n\nUsing the Command design pattern describes the following solution:\n\nDefine separate (command) objects that encapsulate a request.\nA class delegates a request to a command object instead of implementing a particular request directly.\nThis enables one to configure a class with a command object that is used to perform a request. The class is no longer coupled to a particular request and has no knowledge (is independent) of how the request is carried out.",
    "iterator": "In object-oriented programming, the iterator pattern is a design pattern in which an iterator is used to traverse a container and access the container's elements. The iterator pattern decouples algorithms from containers; in some cases, algorithms are necessarily container-specific and thus cannot be decoupled.\n\nFor example, the hypothetical algorithm SearchForElement can be implemented generally using a specified type of iterator rather than implementing it as a container-specific algorithm. This allows SearchForElement to be used on any container that supports the required type of iterator.\n\nWhat problems can the Iterator design pattern solve?\n\nThe elements of an aggregate object should be accessed and traversed without exposing its representation (data structures).\nNew traversal operations should be defined for an aggregate object without changing its interface.\nDefining access and traversal operations in the aggregate interface is inflexible because it commits the aggregate to particular access and traversal operations and makes it impossible to add new operations later without having to change the aggregate interface.\n\nWhat solution does the Iterator design pattern describe?\n\nDefine a separate (iterator) object that encapsulates accessing and traversing an aggregate object.\nClients use an iterator to access and traverse an aggregate without knowing its representation (data structures).\nDifferent iterators can be used to access and traverse an aggregate in different ways. \nNew access and traversal operations can be defined independently by defining new iterators.\n\n\nThe essence of the Iterator Pattern is to 'Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation.'.",
    "mediator": "In software engineering, the mediator pattern defines an object that encapsulates how a set of objects interact. This pattern is considered to be a behavioral pattern due to the way it can alter the program's running behavior.\n\nUsually a program is made up of many classes. Logic and computation are distributed among these classes. However, as more classes are added to a program, especially during maintenance and/or refactoring, the problem of communication between these classes may become more complex. This makes the program harder to read and maintain. Furthermore, it can become difficult to change the program, since any change may affect code in several other classes.\n\nWith the mediator pattern, communication between objects is encapsulated within a mediator object. Objects no longer communicate directly with each other, but instead communicate through the mediator. This reduces the dependencies between communicating objects, thereby reducing coupling.\n\nWhat problems can the Mediator design pattern solve?\n\nTight coupling between a set of interacting objects should be avoided.\nIt should be possible to change the interaction between a set of objects independently.\nDefining a set of interacting objects by accessing and updating each other directly is inflexible because it tightly couples the objects to each other and makes it impossible to change the interaction independently from (without having to change) the objects. And it stops the objects from being reusable and makes them hard to test.\n\nTightly coupled objects are hard to implement, change, test, and reuse because they refer to and know about many different objects.\n\nWhat solution does the Mediator design pattern describe?\n\nDefine a separate (mediator) object that encapsulates the interaction between a set of objects.\nObjects delegate their interaction to a mediator object instead of interacting with each other directly.\nThe objects interact with each other indirectly through a mediator object that controls and coordinates the interaction.\n\nThis makes the objects loosely coupled. They only refer to and know about their mediator object and have no explicit knowledge of each other.\n\nThe essence of the Mediator Pattern is to \"define an object that encapsulates how a set of objects interact\". It promotes loose coupling by keeping objects from referring to each other explicitly, and it allows their interaction to be varied independently. Client classes can use the mediator to send messages to other clients, and can receive messages from other clients via an event on the mediator class.",
    "memento": "The memento pattern is a software design pattern that provides the ability to restore an object to its previous state (undo via rollback).\n\nThe memento pattern is implemented with three objects: the originator, a caretaker and a memento. The originator is some object that has an internal state. The caretaker is going to do something to the originator, but wants to be able to undo the change. The caretaker first asks the originator for a memento object. Then it does whatever operation (or sequence of operations) it was going to do. To roll back to the state before the operations, it returns the memento object to the originator. The memento object itself is an opaque object (one which the caretaker cannot, or should not, change). When using this pattern, care should be taken if the originator may change other objects or resources - the memento pattern operates on a single object.\n\nClassic examples of the memento pattern include the seed of a pseudorandom number generator (it will always produce the same sequence thereafter when initialized with the seed state) and the state in a finite state machine.\n\n\nWhat problems can the Memento design pattern solve?\n\nThe internal state of an object should be saved externally so that the object can be restored to this state later.\nThe object's encapsulation must not be violated.\nThe problem is that a well designed object is encapsulated so that its representation (data structure) is hidden inside the object and can't be accessed from outside the object.\n\nWhat solution does the Memento design pattern describe?\n\nMake an object (originator) itself responsible for\n\nsaving its internal state to a (memento) object and\nrestoring to a previous state from a (memento) object.\nOnly the originator that created a memento is allowed to access it.\n\nA client (caretaker) can request a memento from the originator (to save the internal state of the originator) and pass a memento back to the originator (to restore to a previous state). \nThis enables to save and restore the internal state of an originator without violating its encapsulation.",
    "null_object": "In object-oriented computer programming, a null object is an object with no referenced value or with defined neutral (\"null\") behavior. The null object design pattern describes the uses of such objects and their behavior (or lack thereof). It was first published in the Pattern Languages of Program Design book series.\n\nIn most object-oriented languages, such as Java or C#, references may be null. These references need to be checked to ensure they are not null before invoking any methods, because methods typically cannot be invoked on null references.\n\nThe Objective-C language takes another approach to this problem and does nothing when sending a message to nil; if a return value is expected, nil (for objects), 0 (for numeric values), NO (for BOOL values), or a struct (for struct types) with all its members initialised to null/0/NO/zero-initialised struct is returned.\n\n\nInstead of using a null reference to convey absence of an object (for instance, a non-existent customer), one uses an object which implements the expected interface, but whose method body is empty. The advantage of this approach over a working default implementation is that a null object is very predictable and has no side effects: it does nothing.\n\nFor example, a function may retrieve a list of files in a folder and perform some action on each. In the case of an empty folder, one response may be to throw an exception or return a null reference rather than a list. Thus, the code which expects a list must verify that it in fact has one before continuing, which can complicate the design.\n\nBy returning a null object (i.e. an empty list) instead, there is no need to verify that the return value is in fact a list. The calling function may simply iterate the list as normal, effectively doing nothing. It is, however, still possible to check whether the return value is a null object (an empty list) and react differently if desired.\n\nThe null object pattern can also be used to act as a stub for testing, if a certain feature such as a database is not available for testing.",
    "observer": "The observer pattern is a software design pattern in which an object, called the subject, maintains a list of its dependents, called observers, and notifies them automatically of any state changes, usually by calling one of their methods.\n\nIt is mainly used to implement distributed event handling systems, in \"event driven\" software. In those systems, the subject is usually called a \"stream of events\" or \"stream source of events\", while the observers are called \"sink of events\". The stream nomenclature simulates or adapts to a physical setup where the observers are physically separated and have no control over the emitted events of the subject/stream-source. This pattern then perfectly suits any process where data arrives through I/O, that is, where data is not available to the CPU at startup, but can arrive \"randomly\" (HTTP requests, GPIO data, user input from keyboard/mouse/..., distributed databases and blockchains, ...). Most modern languages have built-in \"event\" constructs which implement the observer pattern components. While not mandatory most 'observers' implementations will use background threads listening for subject events and other support mechanism from the kernel (Linux epoll, ...)\n\n\nThe Observer pattern addresses the following problems:\n\nA one-to-many dependency between objects should be defined without making the objects tightly coupled.\nIt should be ensured that when one object changes state an open-ended number of dependent objects are updated automatically.\nIt should be possible that one object can notify an open-ended number of other objects.\nDefining a one-to-many dependency between objects by defining one object (subject) that updates the state of dependent objects directly is inflexible because it couples the subject to particular dependent objects. Still it can make sense from a performance point of view or if the object implementation is tightly coupled (think of low level kernel structures that execute thousands of times a second). Tightly coupled objects can be hard to implement in some scenarios, and reuse because they refer to and know about (how to update) many different objects with different interfaces. In other scenarios tightly coupled objects can be a better option since the compiler will be able to detect errors at compile time and optimize the code at CPU instruction level.\n\nWhat solution does the Observer design pattern describe?\nDefine Subject and Observer objects.\nso that when a subject changes state, all registered observers are notified and updated automatically (and probably asynchronously).\nThe sole responsibility of a subject is to maintain a list of observers and to notify them of state changes by calling their update() operation. \nThe responsibility of observers is to register (and unregister) themselves on a subject (to get notified of state changes) and to update their state (synchronize their state with subject's state) when they are notified. \nThis makes subject and observers loosely coupled. Subject and observers have no explicit knowledge of each other. Observers can be added and removed independently at run-time.\nThis notification-registration interaction is also known as publish-subscribe.\n\nThe observer pattern can cause memory leaks, known as the lapsed listener problem, because in basic implementation it requires both explicit registration and explicit deregistration, as in the dispose pattern, because the subject holds strong references to the observers, keeping them alive. This can be prevented by the subject holding weak references to the observers.\n\n\nTypically, the observer pattern is implemented so the \"subject\" being \"observed\" is part of the object for which state changes are being observed (and communicated to the observers). This type of implementation is considered \"tightly coupled\", forcing both the observers and the subject to be aware of each other and have access to their internal parts, creating possible issues of scalability, speed, message recovery and maintenance (also called event or notification loss), the lack of flexibility in conditional dispersion, and possible hindrance to desired security measures. In some (non-polling) implementations of the publish-subscribe pattern (aka the pub-sub pattern), this is solved by creating a dedicated \"message queue\" server (and sometimes an extra \"message handler\" object) as an extra stage between the observer and the object being observed, thus decoupling the components. In these cases, the message queue server is accessed by the observers with the observer pattern, \"subscribing to certain messages\" knowing only about the expected message (or not, in some cases), while knowing nothing about the message sender itself; the sender also may know nothing about the observers. Other implementations of the publish-subscribe pattern, which achieve a similar effect of notification and communication to interested parties, do not use the observer pattern at all.[3][4]\n\nIn early implementations of multi-window operating systems like OS/2 and Windows, the terms \"publish-subscribe pattern\" and \"event driven software development\" were used as a synonym for the observer pattern.[5]\n\nThe observer pattern, as described in the GoF book, is a very basic concept and does not address removing interest in changes to the observed \"subject\" or special logic to be done by the observed \"subject\" before or after notifying the observers. The pattern also does not deal with recording when change notifications are sent or guaranteeing that they are being received. These concerns are typically handled in message queueing systems of which the observer pattern is only a small part.\n\nRelated patterns: Publish–subscribe pattern, mediator, singleton.\n\n\nThe observer pattern may be used in the absence of publish-subscribe, as in the case where model status is frequently updated. Frequent updates may cause the view to become unresponsive (e.g by invoking many repaint calls); such observers should instead use a timer. Thus instead of being overloaded by change message, the observer will cause the view to represent the approximate state of the model at a regular interval. This mode of observer is particularly useful for progress bars, where the underlying operation's progress changes with several times per second.",
    "state": "The state pattern is a behavioral software design pattern that allows an object to alter its behavior when its internal state changes. This pattern is close to the concept of finite-state machines. The state pattern can be interpreted as a strategy pattern, which is able to switch a strategy through invocations of methods defined in the pattern's interface.\n\nThe state pattern is used in computer programming to encapsulate varying behavior for the same object, based on its internal state. This can be a cleaner way for an object to change its behavior at runtime without resorting to conditional statements and thus improve maintainability.\n\nThe state pattern is set to solve two main problems:\n\nAn object should change its behavior when its internal state changes.\nState-specific behavior should be defined independently. That is, adding new states should not affect the behavior of existing states.\nImplementing state-specific behavior directly within a class is inflexible because it commits the class to a particular behavior and makes it impossible to add a new state or change the behavior of an existing state later independently from (without changing) the class. In this, the pattern describes two solutions:\n\nDefine separate (state) objects that encapsulate state-specific behavior for each state. That is, define an interface (state) for performing state-specific behavior, and define classes that implement the interface for each state.\nA class delegates state-specific behavior to its current state object instead of implementing state-specific behavior directly.\nThis makes a class independent of how state-specific behavior is implemented. New states can be added by defining new state classes. A class can change its behavior at run-time by changing its current state object.",
    "strategy": "In computer programming, the strategy pattern (also known as the policy pattern) is a behavioral software design pattern that enables selecting an algorithm at runtime. Instead of implementing a single algorithm directly, code receives run-time instructions as to which in a family of algorithms to use.[1]\n\nStrategy lets the algorithm vary independently from clients that use it.[2] Strategy is one of the patterns included in the influential book Design Patterns by Gamma et al.[3] that popularized the concept of using design patterns to describe how to design flexible and reusable object-oriented software. Deferring the decision about which algorithm to use until runtime allows the calling code to be more flexible and reusable.\n\nFor instance, a class that performs validation on incoming data may use the strategy pattern to select a validation algorithm depending on the type of data, the source of the data, user choice, or other discriminating factors. These factors are not known until run-time and may require radically different validation to be performed. The validation algorithms (strategies), encapsulated separately from the validating object, may be used by other validating objects in different areas of the system (or even different systems) without code duplication.\n\nTypically the strategy pattern stores a reference to some code in a data structure and retrieves it. This can be achieved by mechanisms such as the native function pointer, the first-class function, classes or class instances in object-oriented programming languages, or accessing the language implementation's internal storage of code via reflection.\n\n\nAccording to the strategy pattern, the behaviors of a class should not be inherited. Instead they should be encapsulated using interfaces. This is compatible with the open/closed principle (OCP), which proposes that classes should be open for extension but closed for modification.\n\nAs an example, consider a car class. Two possible functionalities for car are brake and accelerate. Since accelerate and brake behaviors change frequently between models, a common approach is to implement these behaviors in subclasses. This approach has significant drawbacks: accelerate and brake behaviors must be declared in each new Car model. The work of managing these behaviors increases greatly as the number of models increases, and requires code to be duplicated across models. Additionally, it is not easy to determine the exact nature of the behavior for each model without investigating the code in each.\n\nThe strategy pattern uses composition instead of inheritance. In the strategy pattern, behaviors are defined as separate interfaces and specific classes that implement these interfaces. This allows better decoupling between the behavior and the class that uses the behavior. The behavior can be changed without breaking the classes that use it, and the classes can switch between behaviors by changing the specific implementation used without requiring any significant code changes. Behaviors can also be changed at run-time as well as at design-time. For instance, a car object's brake behavior can be changed from BrakeWithABS() to Brake() by changing the brakeBehavior member to:\n\nbrakeBehavior = new Brake();",
    "template_method": "In object-oriented programming, the template method is one of the behavioral design patterns identified by Gamma et al. in the book Design Patterns. The template method is a method in a superclass, usually an abstract superclass, and defines the skeleton of an operation in terms of a number of high-level steps. These steps are themselves implemented by additional helper methods in the same class as the template method.\n\nThe helper methods may be either abstract methods, for which case subclasses are required to provide concrete implementations, or hook methods, which have empty bodies in the superclass. Subclasses can (but are not required to) customize the operation by overriding the hook methods. The intent of the template method is to define the overall structure of the operation, while allowing subclasses to refine, or redefine, certain steps.\n\nThis pattern has two main parts:\n\nThe \"template method\" is implemented as a method in a base class (usually an abstract class). This method contains code for the parts of the overall algorithm that are invariant. The template ensures that the overarching algorithm is always followed. In the template method, portions of the algorithm that may vary are implemented by sending self messages that request the execution of additional helper methods. In the base class, these helper methods are given a default implementation, or none at all (that is, they may be abstract methods).\nSubclasses of the base class \"fill in\" the empty or \"variant\" parts of the \"template\" with specific algorithms that vary from one subclass to another.[3] It is important that subclasses do not override the template method itself.\nAt run-time, the algorithm represented by the template method is executed by sending the template message to an instance of one of the concrete subclasses. Through inheritance, the template method in the base class starts to execute. When the template method sends a message to self requesting one of the helper methods, the message will be received by the concrete sub-instance. If the helper method has been overridden, the overriding implementation in the sub-instance will execute; if it has not been overridden, the inherited implementation in the base class will execute. This mechanism ensures that the overall algorithm follows the same steps every time, while allowing the details of some steps to depend on which instance received the original request to execute the algorithm.\n\nThis pattern is an example of inversion of control because the high-level code no longer determines what algorithms to run; a lower-level algorithm is instead selected at run-time.\n\nSome of the self messages sent by the template method may be to hook methods. These methods are implemented in the same base class as the template method, but with empty bodies (i.e., they do nothing). Hook methods exist so that subclasses can override them, and can thus fine-tune the action of the algorithm without the need to override the template method itself. In other words, they provide a \"hook\" on which to \"hang\" variant implementations.\n\n\nThe template method is used in frameworks, where each implements the invariant parts of a domain's architecture, while providing hook methods for customization. This is an example of inversion of control. The template method is used for the following reasons.\n\nIt lets subclasses implement varying behavior (through overriding of the hook methods).\nIt avoids duplication in the code: the general workflow of the algorithm is implemented once in the abstract class's template method, and necessary variations are implemented in the subclasses.\nIt control the point(s) at which specialization is permitted. If the subclasses were to simply override the template method, they could make radical and arbitrary changes to the workflow. In contrast, by overriding only the hook methods, only certain specific details of the workflow can be changed, and the overall workflow is left intact.\n\nThe template pattern is useful when working with auto-generated code. The challenge of working with generated code is that changes to the source code will lead to changes in the generated code; if hand-written modifications have been made to the generated code, these will be lost. How, then, should the generated code be customized?\n\nThe Template pattern provides a solution. If the generated code follows the template method pattern, the generated code will all be an abstract superclass. Provided that hand-written customizations are confined to a subclass, the code generator can be run again without risk of over-writing these modifications. When used with code generation, this pattern is sometimes referred to as the generation gap pattern.",
    "visitor": "In object-oriented programming and software engineering, the visitor design pattern is a way of separating an algorithm from an object structure on which it operates. A practical result of this separation is the ability to add new operations to existing object structures without modifying the structures. It is one way to follow the open/closed principle.\n\nIn essence, the visitor allows adding new virtual functions to a family of classes, without modifying the classes. Instead, a visitor class is created that implements all of the appropriate specializations of the virtual function. The visitor takes the instance reference as input, and implements the goal through double dispatch.\n\nWhat problems can the Visitor design pattern solve?\n\nIt should be possible to define a new operation for (some) classes of an object structure without changing the classes.\nWhen new operations are needed frequently and the object structure consists of many unrelated classes, it's inflexible to add new subclasses each time a new operation is required because \"[..] distributing all these operations across the various node classes leads to a system that's hard to understand, maintain, and change.\" [1]\n\nWhat solution does the Visitor design pattern describe?\n\nDefine a separate (visitor) object that implements an operation to be performed on elements of an object structure.\nClients traverse the object structure and call a dispatching operation accept(visitor) on an element — that \"dispatches\" (delegates) the request to the \"accepted visitor object\". The visitor object then performs the operation on the element (\"visits the element\").\nThis makes it possible to create new operations independently from the classes of an object structure by adding new visitor objects.\n\nMoving operations into visitor classes is beneficial when\n\nmany unrelated operations on an object structure are required,\nthe classes that make up the object structure are known and not expected to change,\nnew operations need to be added frequently,\nan algorithm involves several classes of the object structure, but it is desired to manage it in one single location,\nan algorithm needs to work across several independent class hierarchies.\nA drawback to this pattern, however, is that it makes extensions to the class hierarchy more difficult, as new classes typically require a new visit method to be added to each visitor.\n\n\nThe Gang of Four defines the Visitor as:\n\nRepresent an operation to be performed on elements of an object structure. Visitor lets you define a new operation without changing the classes of the elements on which it operates.\n\nThe nature of the Visitor makes it an ideal pattern to plug into public APIs thus allowing its clients to perform operations on a class using a \"visiting\" class without having to modify the source."
  },
  "more":{
    "service_locator": "The service locator pattern is a design pattern or anti-pattern used in software development to encapsulate the processes involved in obtaining a service with a strong abstraction layer. This pattern uses a central registry known as the \"service locator\", which on request returns the information necessary to perform a certain task.[1] The main criticism of service location is that it obscures dependencies.[2] Meanwhile, its proponents say the approach should not be discarded as it simplifies component-based applications where all dependencies are cleanly listed at the beginning of the whole application design, consequently making traditional dependency injection a more complex way of connecting objects. The usual criticism of service locator pattern as being the one which is \"much harder to test\" actually becomes a benefit in such applications.\n\nThe \"service locator\" can act as a simple run-time linker. This allows code to be added at run-time without re-compiling the application, and in some cases without having to even restart it.\nApplications can optimize themselves at run-time by selectively adding and removing items from the service locator. For example, an application can detect that it has a better library for reading JPG images available than the default one, and alter the registry accordingly.\nLarge sections of a library or application can be completely separated. The only link between them becomes the registry.\nAn application may use multiple structured service locators purposed for particular functionality/testing. Service locator does not mandate one single static class per process\nThe solution may be simpler with service locator (vs. dependency injection) in applications with well-structured component/service design. In these cases the disadvantages may actually be considered as an advantage (e.g. no need to supply various dependencies to every class and maintain dependency configurations)\n\nDisadvantages:\nThe registry hides the class' dependencies, causing run-time errors instead of compile-time errors when dependencies are missing (similar to using Dependency injection).\nThe registry makes the code more difficult to maintain (similar to using Dependency injection), because it becomes unclear when you would be introducing a breaking change.\nThe registry makes code harder to test, since all tests need to interact with the same global service locator class to set the fake dependencies of a class under test. However, this is easily overcome by injecting application classes with a single service locator interface.",
    "repository": "The Repository Pattern has gained quite a bit of popularity since it was first introduced as a part of Domain-Driven Design in 2004. Essentially, it provides an abstraction of data, so that your application can work with a simple abstraction that has an interface approximating that of a collection. Adding, removing, updating, and selecting items from this collection is done through a series of straightforward methods, without the need to deal with database concerns like connections, commands, cursors, or readers. Using this pattern can help achieve loose coupling and can keep domain objects persistence ignorant. Although the pattern is very popular (or perhaps because of this), it is also frequently misunderstood and misused. There are many different ways to implement the Repository pattern. Let’s consider a few of them, and their merits and drawbacks.\n\nRepository Per Entity or Business Object\nThe simplest approach, especially with an existing system, is to create a new Repository implementation for each business object you need to store to or retrieve from your persistence layer. Further, you should only implement the specific methods you are calling in your application. Avoid the trap of creating a “standard” repository class, base class, or default interface that you must implement for all repositories. Yes, if you need to have an Update or a Delete method, you should strive to make its interface consistent (does Delete take an ID, or does it take the object itself?), but don’t implement a Delete method on your LookupTableRepository that you’re only ever going to be calling List() on. The biggest benefit of this approach is YAGNI – you won’t waste any time implementing methods that never get called.\n\nProbably the most important distinction about repositories is that they represent collections of entities. They do not represent database storage or caching or any number of technical concerns. Repositories represent collections. How you hold those collections is simply an implementation detail.\n\nI want to make this point clear. A repository is a collection, a collection that holds entities and which can filter and return entities back based on the needs of your application. How it actually holds those entities is an IMPLEMENTATION DETAIL.\n\nIn the world of PHP we're used to the Request / Response cycle followed by the death of the PHP process. Anything that isn't persisted externally is gone for good, at this point. Now, not all platforms work this way.\n\nI find that a good thought-experiment to help understand repositories is to imagine that your application is always running and that objects always stay in memory. We're not worried about critical failures for this experiment. Imagine that you have a singleton repository for Member entities, MemberRepository.\n\nThen, you create a new Member and add it to the repository. Later, you ask the repository for all members and you receive back a collection that contains the Member you added. Perhaps you want to pull back a specific member by ID, you can do that too. It's easy to imagine that inside the repository these Member objects are stored in an array or better yet a collection object.\n\nSimply put, a repository is a special kind of authoritative collection that you'll use over and over to hold and filter back entities.",
    "entity-attribute-value": "Entity–attribute–value model (EAV) is a data model to encode, in a space-efficient manner, entities where the number of attributes (properties, parameters) that can be used to describe them is potentially vast, but the number that will actually apply to a given entity is relatively modest. Such entities correspond to the mathematical notion of a sparse matrix.\n\nEAV is also known as object–attribute–value model, vertical database model, and open schema.\n\n\nThis data representation is analogous to space-efficient methods of storing a sparse matrix, where only non-empty values are stored. In an EAV data model, each attribute-value pair is a fact describing an entity, and a row in an EAV table stores a single fact. EAV tables are often described as \"long and skinny\": \"long\" refers to the number of rows, \"skinny\" to the few columns.\n\nData is recorded as three columns:\n\nThe entity: the item being described.\nThe attribute or parameter: typically implemented as a foreign key into a table of attribute definitions. The attribute definitions table might contain the following columns: an attribute ID, attribute name, description, data type, and columns assisting input validation, e.g., maximum string length and regular expression, set of permissible values, etc.\nThe value of the attribute.\n\n\nConsider how one would try to represent a general-purpose clinical record in a relational database. Clearly creating a table (or a set of tables) with thousands of columns is not feasible, because the vast majority of columns would be null. To complicate things, in a longitudinal medical record that follows the patient over time, there may be multiple values of the same parameter: the height and weight of a child, for example, change as the child grows. Finally, the universe of clinical findings keeps growing: for example, diseases emerge and new lab tests are devised; this would require constant addition of columns, and constant revision of the user interface. (The situation where the list of attributes changes frequently is termed \"attribute volatility\" in database parlance.)\n\nThe following shows a snapshot of an EAV table for clinical findings from a visit to a doctor for a fever on the morning of 1/5/98. The entries shown within angle brackets are references to entries in other tables, shown here as text rather than as encoded foreign key values for ease of understanding. In this example, the values are all literal values, but they could also be pre-defined value lists. The latter are particularly useful when the possible values are known to be limited (i.e., enumerable).\n\nThe entity. For clinical findings, the entity is the patient event: a foreign key into a table that contains at a minimum a patient ID and one or more time-stamps (e.g., the start and end of the examination date/time) that record when the event being described happened.\nThe attribute or parameter: a foreign key into a table of attribute definitions (in this example, definitions of clinical findings). At the very least, the attribute definitions table would contain the following columns: an attribute ID, attribute name, description, data type, units of measurement, and columns assisting input validation, e.g., maximum string length and regular expression, maximum and minimum permissible values, set of permissible values, etc.\nThe value of the attribute. This would depend on the data type, and we discuss how values are stored shortly.\n\nDescription of concepts\nThe entity\nIn clinical data, the entity is typically a clinical event, as described above. In more general-purpose settings, the entity is a foreign key into an \"objects\" table that records common information about every \"object\" (thing) in the database – at the minimum, a preferred name and brief description, as well as the category/class of entity to which it belongs. Every record (object) in this table is assigned a machine-generated object ID.\n\nThe \"objects table\" approach was pioneered by Tom Slezak and colleagues at Lawrence Livermore Laboratories for the Chromosome 19 database, and is now standard in most large bioinformatics databases. The use of an objects table does not mandate the concurrent use of an EAV design: conventional tables can be used to store the category-specific details of each object.\n\nThe major benefit to a central objects table is that, by having a supporting table of object synonyms and keywords, one can provide a standard Google-like search mechanism across the entire system where the user can find information about any object of interest without having to first specify the category that it belongs to. (This is important in bioscience systems where a keyword like \"acetylcholine\" could refer either to the molecule itself, which is a neurotransmitter, or the biological receptor to which it binds.\n\nThe attribute\nIn the EAV table itself, this is just an attribute ID, a foreign key into an Attribute Definitions table, as stated above. However, there are usually multiple metadata tables that contain attribute-related information, and these are discussed shortly.\n\nThe value\nCoercing all values into strings, as in the EAV data example above, results in a simple, but non-scalable, structure: constant data type inter-conversions are required if one wants to do anything with the values, and an index on the value column of an EAV table is essentially useless. Also, it is not convenient to store large binary data, such as images, in Base64 encoded form in the same table as small integers or strings. Therefore, larger systems use separate EAV tables for each data type (including binary large objects, \"BLOBS\"), with the metadata for a given attribute identifying the EAV table in which its data will be stored. This approach is actually quite efficient because the modest amount of attribute metadata for a given class or form that a user chooses to work with can be cached readily in memory. However, it requires moving of data from one table to another if an attribute’s data type is changed. (This does not happen often, but mistakes can be made in metadata definition just as in database schema design.)" 
  }
}
